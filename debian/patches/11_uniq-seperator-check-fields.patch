--- coreutils-4.5.3.orig/src/uniq.c
+++ coreutils-4.5.3/src/uniq.c
@@ -56,9 +56,16 @@
 /* Number of chars to skip after skipping any fields. */
 static size_t skip_chars;
 
+/* Number of fields to compare. */
+static int check_fields;
+
 /* Number of chars to compare. */
 static size_t check_chars;
 
+/* Separator between fields; if this is NUL, a field is a run of whitespace,
+   then non-whitespace characters. */
+static int tab;
+
 enum countmode
 {
   count_occurrences,		/* -c Print count before output lines. */
@@ -118,6 +125,8 @@
   {"skip-fields", required_argument, NULL, 'f'},
   {"skip-chars", required_argument, NULL, 's'},
   {"check-chars", required_argument, NULL, 'w'},
+  {"check-fields", required_argument, NULL, 'W'},
+  {"separator", required_argument, NULL, 't'},
   {GETOPT_HELP_OPTION_DECL},
   {GETOPT_VERSION_OPTION_DECL},
   {NULL, 0, NULL, 0}
@@ -154,17 +163,19 @@
   -f, --skip-fields=N   avoid comparing the first N fields\n\
   -i, --ignore-case     ignore differences in case when comparing\n\
   -s, --skip-chars=N    avoid comparing the first N characters\n\
+  -t, --separator=SEP   use SEParator to delimit fields\n\
   -u, --unique          only print unique lines\n\
 "), stdout);
      fputs (_("\
   -w, --check-chars=N   compare no more than N characters in lines\n\
+  -W, --check-fields=N  compare no more than N fields in lines\n\
 "), stdout);
      fputs (HELP_OPTION_DESCRIPTION, stdout);
      fputs (VERSION_OPTION_DESCRIPTION, stdout);
      fputs (_("\
 \n\
-A field is a run of whitespace, then non-whitespace characters.\n\
-Fields are skipped before chars.\n\
+A field is a run of whitespace, then non-whitespace characters, unless\n\
+a SEParator is given.  Fields are skipped before chars.\n\
 "), stdout);
       printf (_("\nReport bugs to <%s>.\n"), PACKAGE_BUGREPORT);
     }
@@ -184,6 +195,36 @@
   return size;
 }
 
+/* Given a string,
+   return the length of the first n fields. */
+static int
+find_field_length (const char *string, size_t size, int n)
+{
+  int count;
+  int i = 0;
+
+  if (tab)
+    {
+      for (count = 0; count < n && i < size; count++)
+	{
+	  while (string[i++] != tab && i < size)
+	    ;
+	}
+    }
+  else
+    {
+      for (count = 0; count < n && i < size; count++)
+	{
+	  while (i < size && ISBLANK (string[i]))
+	    i++;
+	  while (i < size && !ISBLANK (string[i]))
+	    i++;
+	}
+    }
+
+  return i;
+}
+
 /* Given a linebuffer LINE,
    return a pointer to the beginning of the line's field to be compared. */
 
@@ -193,15 +234,9 @@
   register size_t count;
   register char *lp = line->buffer;
   register size_t size = line->length - 1;
-  register size_t i = 0;
+  register size_t i;
 
-  for (count = 0; count < skip_fields && i < size; count++)
-    {
-      while (i < size && ISBLANK (lp[i]))
-	i++;
-      while (i < size && !ISBLANK (lp[i]))
-	i++;
-    }
+  i = find_field_length(lp, size, skip_fields);
 
   for (count = 0; count < skip_chars && i < size; count++)
     i++;
@@ -217,6 +252,11 @@
 static int
 different (const char *old, const char *new, size_t oldlen, size_t newlen)
 {
+  if (check_fields)
+    {
+      oldlen = find_field_length(old, oldlen, check_fields);
+      newlen = find_field_length(new, newlen, check_fields);
+    }
   if (check_chars < oldlen)
     oldlen = check_chars;
   if (check_chars < newlen)
@@ -405,6 +445,8 @@
   skip_chars = 0;
   skip_fields = 0;
   check_chars = SIZE_MAX;
+  check_fields = 0;
+  tab = 0;
   mode = output_all;
   countmode = count_none;
   delimit_groups = DM_NONE;
@@ -418,7 +460,7 @@
       if (optc == -1
 	  || (posixly_correct && nfiles != 0)
 	  || ((optc = getopt_long (argc, argv,
-				   "-0123456789Dcdf:is:uw:", longopts, NULL))
+				   "-0123456789DW:cdf:is:t:uw:", longopts, NULL))
 	      == -1))
 	{
 	  if (optind == argc)
@@ -502,6 +544,10 @@
 				 N_("invalid number of bytes to skip"));
 	  break;
 
+	case 't':
+	  tab = *optarg;
+	  break;
+
 	case 'u':
 	  mode = output_unique;
 	  break;
@@ -511,6 +557,18 @@
 				  N_("invalid number of bytes to compare"));
 	  break;
 
+	case 'W':
+	  {
+	    long int tmp_long;
+	    if (xstrtol (optarg, NULL, 10, &tmp_long, "") != LONGINT_OK
+		|| tmp_long <= 0 || tmp_long > INT_MAX)
+	      error (EXIT_FAILURE, 0,
+		     _("invalid number of fields to compare: `%s'"),
+		     optarg);
+	    check_fields = (int) tmp_long;
+	  }
+	  break;
+
 	case_GETOPT_HELP_CHAR;
 
 	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
