diff -ruN coreutils-5.97-old/tests/misc/pwd-long coreutils-5.97/tests/misc/pwd-long
--- coreutils-5.97-old/tests/misc/pwd-long	2006-06-05 22:51:23.000000000 -0500
+++ coreutils-5.97/tests/misc/pwd-long	2007-01-23 14:22:37.000000000 -0600
@@ -33,14 +33,39 @@
 # Show that pwd works even when the length of the resulting
 # directory name is longer than PATH_MAX.
 use strict;
-use Cwd;
 
 (my $ME = $ENV{ARGV_0}) =~ s|.*/||;
 
-my $cwd = $ENV{CWD};
+sub normalize_to_cwd_relative ($$$)
+{
+  my ($dir, $dev, $ino) = @_;
+  my $slash = -1;
+  my $next_slash;
+  while (1)
+    {
+      $slash = index $dir, '/', $slash + 1;
+      $slash <= -1
+	and die "$ME: $dir does not contain old CWD\n";
+      my $dir_prefix = $slash ? substr ($dir, 0, $slash) : '/';
+      my ($d, $i) = (stat $dir_prefix)[0, 1];
+      $d == $dev && $i == $ino
+	and return substr $dir, $slash + 1;
+    }
+}
+
+# Set up a safe, well-known environment
+delete @ENV{qw(BASH_ENV CDPATH ENV PATH)};
+$ENV{IFS}  = '';
+
+# Save CWD's device and inode numbers.
+my ($dev, $ino) = (stat '.')[0, 1];
+
+# Construct the expected "."-relative part of pwd's output.
 my $z = 'z' x 31;
 my $n = 256;
-my $expected = $cwd . ("/$z" x $n);
+my $expected = "/$z" x $n;
+# Remove the leading "/".
+substr ($expected, 0, 1) = '';
 
 my $i = 0;
 do
@@ -58,6 +83,15 @@
 -x $pwd_binary
   or die "$ME: $pwd_binary is not an executable file\n";
 chomp (my $actual = `$pwd_binary`);
+
+# Convert the absolute name from pwd into a $CWD-relative name.
+# This is necessary in order to avoid a spurious failure when run
+# from a directory in a bind-mounted partition.  What happens is
+# pwd reads a ".." that contains two or more entries with identical
+# dev,ino that match the ones we're looking for, and it chooses a
+# name that does not correspond to the one already recorded in $CWD.
+$actual = normalize_to_cwd_relative $actual, $dev, $ino;
+
 $expected eq $actual
   or die "$ME: $expected\n$actual\n";
 EOF
