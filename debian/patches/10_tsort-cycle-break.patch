--- coreutils-4.5.3.orig/src/tsort.c
+++ coreutils-4.5.3/src/tsort.c
@@ -55,7 +55,9 @@
   const char *str;
   struct item *left, *right;
   int balance;
-  int count;
+  struct item *eqnext, *eqtail;
+  enum { unvisited, visiting, visited } status;
+  int depth;
   struct item *qlink;
   struct successor *top;
 };
@@ -72,14 +74,8 @@
 /* The head of the sorted list.  */
 static struct item *head = NULL;
 
-/* The tail of the list of `zeros', strings that have no predecessors.  */
-static struct item *zeros = NULL;
-
-/* Used for loop detection.  */
-static struct item *loop = NULL;
-
-/* The number of strings to sort.  */
-static int n_strings = 0;
+/* True if there are loops. */
+static int loop_found = 0;
 
 static struct option const long_options[] =
 {
@@ -118,10 +114,11 @@
   k->left = k->right = NULL;
   k->balance = 0;
 
-  /* T1. Initialize (COUNT[k] <- 0 and TOP[k] <- ^).  */
-  k->count = 0;
   k->qlink = NULL;
   k->top = NULL;
+  k->eqnext = NULL;
+  k->eqtail = k;
+  k->status = unvisited;
 
   return k;
 }
@@ -286,7 +283,6 @@
 
   if (!STREQ (j->str, k->str))
     {
-      k->count++;
       p = xmalloc (sizeof (struct successor));
       p->suc = k;
       p->next = j->top;
@@ -295,117 +291,73 @@
 }
 
 static int
-count_items (struct item *unused ATTRIBUTE_UNUSED)
+dfs(struct item *k, int *depth)
 {
-  n_strings++;
-  return 0;
-}
+  struct successor *p;
+  int cycle_start, new_cycle_start;
 
-static int
-scan_zeros (struct item *k)
-{
-  /* Ignore strings that have already been printed.  */
-  if (k->count == 0 && k->str)
+  k->depth = cycle_start = (*depth)++;
+  k->status = visiting;
+  for (p = k->top; p; p = p->next)
     {
-      if (head == NULL)
-	head = k;
-      else
-	zeros->qlink = k;
-
-      zeros = k;
+      switch (p->suc->status)
+	{
+	case unvisited:
+	  new_cycle_start = dfs(p->suc, depth);
+	  if (new_cycle_start < p->suc->depth)
+	    {
+	      k->eqtail->eqnext = p->suc;
+	      k->eqtail = p->suc->eqtail;
+	      if (new_cycle_start < cycle_start)
+		cycle_start = new_cycle_start;
+	    }
+	  break;
+	case visiting:
+	  if (p->suc->depth < cycle_start)
+	    cycle_start = p->suc->depth;
+	  break;
+	case visited:
+	  break;
+	}
     }
 
-  return 0;
-}
-
-/* Try to detect the loop.  If we have detected that K is part of a
-   loop, print the loop on standard error, remove a relation to break
-   the loop, and return non-zero.
-
-   The loop detection strategy is as follows: Realise that what we're
-   dealing with is essentially a directed graph.  If we find an item
-   that is part of a graph that contains a cycle we traverse the graph
-   in backwards direction.  In general there is no unique way to do
-   this, but that is no problem.  If we encounter an item that we have
-   encountered before, we know that we've found a cycle.  All we have
-   to do now is retrace our steps, printing out the items until we
-   encounter that item again.  (This is not necessarily the item that
-   we started from originally.)  Since the order in which the items
-   are stored in the tree is not related to the specified partial
-   ordering, we may need to walk the tree several times before the
-   loop has completely been constructed.  If the loop was found, the
-   global variable LOOP will be NULL.  */
-
-static int
-detect_loop (struct item *k)
-{
-  if (k->count > 0)
+  if (cycle_start == k->depth)
     {
-      /* K does not have to be part of a cycle.  It is however part of
-	 a graph that contains a cycle.  */
-
-      if (loop == NULL)
-	/* Start traversing the graph at K.  */
-	loop = k;
-      else
+      if (k->eqnext)
 	{
-	  struct successor **p = &k->top;
-
-	  while (*p)
+	  struct item *j = k;
+	  error (0, 0, _("input contains a loop:\n"));
+	  do
 	    {
-	      if ((*p)->suc == loop)
-		{
-		  if (k->qlink)
-		    {
-		      /* We have found a loop.  Retrace our steps.  */
-		      while (loop)
-			{
-			  struct item *tmp = loop->qlink;
-
-			  fprintf (stderr, "%s: %s\n", program_name,
-				   loop->str);
-
-			  /* Until we encounter K again.  */
-			  if (loop == k)
-			    {
-			      /* Remove relation.  */
-			      (*p)->suc->count--;
-			      *p = (*p)->next;
-			      break;
-			    }
-
-			  /* Tidy things up since we might have to
-                             detect another loop.  */
-			  loop->qlink = NULL;
-			  loop = tmp;
-			}
-
-		      while (loop)
-			{
-			  struct item *tmp = loop->qlink;
-
-			  loop->qlink = NULL;
-			  loop = tmp;
-			}
-
-		      /* Since we have found the loop, stop walking
-                         the tree.  */
-		      return 1;
-		    }
-		  else
-		    {
-		      k->qlink = loop;
-		      loop = k;
-		      break;
-		    }
-		}
-
-	      p = &(*p)->next;
+	      fprintf (stderr, "%s: %s\n", program_name, j->str);
+	      j->status = visited;
+	      j->qlink = head;
+	      head = j;
 	    }
+	  while ((j = j->eqnext));
+	  loop_found = 1;
+	}
+      else
+	{
+	  k->status = visited;
+	  k->qlink = head;
+	  head = k;
 	}
     }
 
-  return 0;
+  return cycle_start;
+}
+
+static void
+tsort_node (struct item *k)
+{
+  int depth;
+
+  if (k->status == visited)
+    return;
+
+  depth = 0;
+  dfs(k, &depth);
 }
 
 /* Recurse (sub)tree rooted at ROOT, calling ACTION for each node.
@@ -491,55 +443,14 @@
       j = k;
     }
 
-  /* T1. Initialize (N <- n).  */
-  walk_tree (root, count_items);
-
-  while (n_strings > 0)
+  walk_tree (root, tsort_node);
+  while (head)
     {
-      /* T4. Scan for zeros.  */
-      walk_tree (root, scan_zeros);
-
-      while (head)
-	{
-	  struct successor *p = head->top;
-
-	  /* T5. Output front of queue.  */
-	  printf ("%s\n", head->str);
-	  head->str = NULL;	/* Avoid printing the same string twice.  */
-	  n_strings--;
-
-	  /* T6. Erase relations.  */
-	  while (p)
-	    {
-	      p->suc->count--;
-	      if (p->suc->count == 0)
-		{
-		  zeros->qlink = p->suc;
-		  zeros = p->suc;
-		}
-
-	      p = p->next;
-	    }
-
-	  /* T7. Remove from queue.  */
-	  head = head->qlink;
-	}
-
-      /* T8.  End of process.  */
-      assert (n_strings >= 0);
-      if (n_strings > 0)
-	{
-	  /* The input contains a loop.  */
-	  error (0, 0, _("%s: input contains a loop:"),
-		 (have_read_stdin ? "-" : file));
-	  exit_status = 1;
-
-	  /* Print the loop and remove a relation to break it.  */
-	  do
-	    walk_tree (root, detect_loop);
-	  while (loop);
-	}
+      printf ("%s\n", head->str);
+      head = head->qlink;
     }
+  if (loop_found)
+    exit_status = 1;
 }
 
 int
